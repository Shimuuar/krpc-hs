{-# LANGUAGE ViewPatterns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
{-# LANGUAGE TemplateHaskell   #-}
import           Control.Monad
import           Data.List
import           Data.List.Split
import           Data.Text     (Text)
import           Data.Aeson    (Value,eitherDecode)
import           Data.Aeson.TH
import           Data.Char
import           Data.Monoid
import           Data.Maybe
import           Data.Foldable
import           Data.String.Interpolate
import qualified Data.ByteString.Lazy as BL
import qualified Data.HashMap.Strict as HM
import qualified Data.HashSet        as HS
import qualified Data.Text as T
import System.Environment (getArgs)
import TH

----------------------------------------------------------------
data KRPCModule = KRPCModule
  { modId            :: Int
  , modDocumentation :: Text
  , modProcedures    :: HM.HashMap Text Procedure
  , modClasses       :: HM.HashMap Text KRPCClass
  , modEnumerations  :: HM.HashMap Text KRPCEnum
  , modExceptions    :: Value
  }
  deriving (Show,Eq)

data KRPCEnum = KRPCEnum
  { enumDocumentation :: Text
  , enumValues        :: [EnumVal]
  }
  deriving (Show,Eq)

data EnumVal = EnumVal
  { evName          :: Text
  , evValue         :: Int
  , evDocumentation :: Text
  }
  deriving (Show,Eq)

data KRPCClass = KRPCClass
  { clsDocumentation :: Text
  }
  deriving (Show,Eq)

data Procedure = Procedure
  { procId                 :: Int
  , procParameters         :: [Param]
  , procReturn_type        :: Maybe Type
  , procReturn_is_nullable :: Maybe Bool
  , procDocumentation      :: Text
  }
  deriving (Show,Eq)

data Type = Type
  { tyCode    :: Text
  , tyClass   :: Maybe Text
  , tyService :: Maybe Text
  , tyTypes   :: Maybe [Type]
  , tyName    :: Maybe Text
  }
  deriving (Show,Eq)

data Param = Param
  { parName :: Text
  , parType :: Type
  }
  deriving (Show,Eq)

deriveJSONpref "mod"  'KRPCModule
deriveJSONpref "enum" 'KRPCEnum
deriveJSONpref "ev"   'EnumVal
deriveJSONpref "cls"  'KRPCClass
deriveJSONpref "proc" 'Procedure
deriveJSONpref "ty"   'Type
deriveJSONpref "par"  'Param

----------------------------------------------------------------

data Module = Module
  { hsService :: Text
    -- ^ Service name
  , hsClasses :: HM.HashMap Text KRPCClass
    -- ^ Classes
  , hsEnums   :: HM.HashMap Text KRPCEnum
    -- Enumerations defined in service
  , hsProcs   :: [Procedure]
  }
  deriving (Show)

-- | Enumeration of all supported types
data Ty
  = Unit
  | Double
  | Float
  | Int32
  | Int64
  | Word32
  | Word64
  | Bool
  | Text
  | Class   Text Text
  | Enum    Text Text
  | Set     Ty
  | List    Ty
  | Dict    Ty Ty
  | Tuple   [Ty]
  deriving (Show)


convertModule :: Text -> KRPCModule -> Module
convertModule srv m = Module
  { hsService = srv
  , hsClasses = modClasses m
  , hsEnums   = modEnumerations m
  , hsProcs   = undefined
  }

-- | Extract type information
parseType :: Type -> Ty
parseType Type{tyCode="DOUBLE"} = Double
parseType Type{tyCode="FLOAT"}  = Float
parseType Type{tyCode="SINT32"} = Int32
parseType Type{tyCode="SINT64"} = Int64
parseType Type{tyCode="UINT32"} = Word32
parseType Type{tyCode="UINT64"} = Word64
parseType Type{tyCode="BOOL"}   = Bool
parseType Type{tyCode="STRING"} = Text
parseType Type{tyCode="SET", tyTypes=Just [ty]}
  = Set (parseType ty)
parseType Type{tyCode="LIST", tyTypes=Just [ty]}
  = List (parseType ty)
parseType Type{tyCode="DICTIONARY", tyTypes=Just [k,v]}
  = Dict (parseType k) (parseType v)
parseType Type{tyCode="CLASS", tyService=Just srv, tyName=Just nm}
  = Class srv nm
parseType Type{tyCode="ENUMERATION", tyService=Just srv, tyName=Just nm}
  = Enum srv nm
parseType Type{tyCode="TUPLE", tyTypes=Just xs}
  = Tuple (map parseType xs)
parseType ty = error (show ty)

----------------------------------------------------------------
-- Pretty-printing
----------------------------------------------------------------

-- Generate full haskell module
renderModule :: Module -> String
renderModule m =
  [i|
-- ! *** DO NOT EDIT ***
-- !
-- ! This file is automatically generated from JSON description of RPC
-- ! interface
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module KRPCHS.Service.#{hsService m} where
{
import           Data.Int
import           Data.Map  (Map)
import           Data.Set  (Set)
import qualified Data.Text (Text)
import           Data.Word

import Control.Monad.Catch
import Control.Monad.IO.Class

import KRPCHS.Internal.Requests
import KRPCHS.Internal.SerializeUtils

{T.unlines $ moduleImports srv md}

#{unlines $ map renderClass      $ HM.toList $ hsClasses m }
#{unlines $ map renderEnum       $ HM.toList $ hsEnums   m }
{unlines $ map (pprProc srv) $ HM.toList $ modProcedures md }
|]

renderClass :: (Text, KRPCClass) -> String
renderClass (nm, c) = [i|
{-| #{clsDocumentation c} -}
newtype #{nm} = #{nm} Int
  deriving (Show,Eq,Ord,PbSerializable)
instance KRPCResponseExtractable #{nm}
instance KRPCObject #{nm} where
  isKrpcNull (#{nm} i) = i == 0|]

renderEnum :: (Text, KRPCEnum) -> String
renderEnum (nm, e)
  = [i|
{-| #{enumDocumentation e} -}
data #{nm}
  = #{T.intercalate "\n  | " [ nm<>"'"<>evName c | c <- evals]}
  deriving (Show,Eq,Ord,Enum)

instance PbSerializable #{nm} where
  encodePb   = encodePb . (fromIntegral :: Int -> Int32) . fromEnum
  decodePb b = toEnum . (fromIntegral :: Int32 -> Int) <$> decodePb b
instance KRPCResponseExtractable #{nm}|]
  where
    evals = sortOn evValue (enumValues e)



-- Pretty print type information
pprType :: Bool -> Ty -> Text
pprType False Double = "Double"
pprType False Float  = "Float"
pprType False Int32  = "Int32"
pprType False Int64  = "Int64"
pprType False Word32 = "Word32"
pprType False Word64 = "Word64"
pprType False Bool   = "Bool"
pprType False Text   = "Data.Text.Text"
pprType False (Set ty)
  = "(Set " <> pprType False ty <> ")"
pprType False (List ty)
  = "[" <> pprType False ty <> "]"
pprType False (Dict k v)
  = "(Map " <> pprType False k <> " " <> pprType False v <> ")"
pprType False (Class srv nm)
  = "KRPCHS.Service."<>srv<>"."<>nm
pprType True  (Class srv nm)
  = "(Maybe KRPCHS.Service."<>srv<>"."<>nm<>")"
pprType False (Enum srv nm)
  = "KRPCHS.Service."<>srv<>"."<>nm
pprType False (Tuple xs)
  = "(" <> T.intercalate "," (map (pprType False) xs) <> ")"
pprType n ty = error (show (n,ty))

-- Pretty-print class declaration
pprClass :: (Text,KRPCClass) -> String
pprClass (nm,c) = [i|
{-| #{clsDocumentation c} -}
newtype #{nm} = #{nm} Int
  deriving (Show,Eq,Ord,PbSerializable)
instance KRPCResponseExtractable #{nm}
instance KRPCObject #{nm} where
  isKrpcNull (#{nm} i) = i == 0|]

pprEnum :: (Text,KRPCEnum) -> String
pprEnum (nm,e)
  = [i|
{-| #{enumDocumentation e} -}
data #{nm}
  = #{T.intercalate "\n  | " [ nm<>"'"<>evName c | c <- evals]}
  deriving (Show,Eq,Ord,Enum)

instance PbSerializable #{nm} where
  encodePb   = encodePb . (fromIntegral :: Int -> Int32) . fromEnum
  decodePb b = toEnum . (fromIntegral :: Int32 -> Int) <$> decodePb b
instance KRPCResponseExtractable #{nm}|]
  where
    evals = sortOn evValue (enumValues e)

-- Generate name of procedure
mangleProcName :: Text -> Text
mangleProcName s = T.pack $ case splitOn "_" (T.unpack s) of
  [nm1,"get",nm2] -> "get" <> uc nm1 <> uc nm2
  [nm1,"set",nm2] -> "set" <> uc nm1 <> uc nm2
  [nm1,"static",nm2] -> "static" <> uc nm1 <> uc nm2
  [nm1,nm2]       -> lc nm1 <> nm2
  [nm1]           -> lc nm1
  _               -> error (T.unpack s)
  where
    lc (c:cs) = toLower c : cs
    uc (c:cs) = toUpper c : cs

-- Pretty-print procedure
--
-- FIXME: insert doc
pprProc :: Text -> (Text,Procedure) -> String
pprProc srv (nm,prc)
  = [i|
#{name} :: #{T.intercalate " -> " allTypes}
#{name} #{T.intercalate " " parNms} =
  RpcCall
    (makeRequest "#{srv}" #{procId prc} [#{intercalate ", " args}])
    #{extract}|]
  where
    name   = case procReturn_is_nullable prc of
               -- Just True -> error "A"
               _ -> mangleProcName nm
    retT   = case procReturn_type prc of
               Nothing -> "()"
               Just (parseType -> t)  -> case procReturn_is_nullable prc of
                 Just True  -> pprType True  t
                 Just False -> pprType False t
                 Nothing    -> pprType False t
    realT | retT == "Float" = "Double"
          | otherwise       = retT
    extract
      | retT == "Float" = "(fmap (realToFrac :: Float -> Double) . extract)"
      | otherwise       = "extract"
    types    = map (pprType False . parseType . parType) (procParameters prc)
    allTypes = [ if ty == "Float" then "Double" else ty | ty <- types]
            ++ ["RpcCall " <> realT]
    parNms = [ case nm of "type" -> "type_"
                          _      -> nm
             | nm <- map parName (procParameters prc)
             ]
    args   = [ case ty of
                 "Float" -> [i|makeArgument #{n} (realToFrac #{arg} :: Float)|]
                 _       -> [i|makeArgument #{n} #{arg}|]
             | (n,arg,ty) <- zip3 [0..] parNms types
             ]

moduleImports :: Text -> KRPCModule -> [Text]
moduleImports srv
  = id
  . map ("import qualified KRPCHS.Service."<>)
  . filter (/= srv)
  . HS.toList
  . foldMap procServices
  . modProcedures
  where
    procServices p = HS.fromList
      [ srv | Type{tyService=Just srv} <- maybeToList (procReturn_type p)
                                       ++ map parType (procParameters p)
            ]


-- Generate full haskell module
generateModule :: FilePath -> IO (String,FilePath)
generateModule fname = do
  bs <- BL.readFile fname
  let srv :: Text
      md  :: KRPCModule
      (srv, md) = case HM.toList <$> eitherDecode bs of
        Right [x] -> x
        Right _   -> error "Multiple values"
        Left e    -> error e
  return ([i|
-- ! *** DO NOT EDIT ***
-- !
-- ! This file is automatically generated from JSON description of RPC
-- ! interface
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module KRPCHS.Service.#{srv} where

import           Data.Int
import           Data.Map  (Map)
import           Data.Set  (Set)
import qualified Data.Text (Text)
import           Data.Word

import Control.Monad.Catch
import Control.Monad.IO.Class

import KRPCHS.Internal.Requests
import KRPCHS.Internal.SerializeUtils

#{T.unlines $ moduleImports srv md}

#{unlines $ map pprClass      $ HM.toList $ modClasses md }
#{unlines $ map pprEnum       $ HM.toList $ modEnumerations md }
#{unlines $ map (pprProc srv) $ HM.toList $ modProcedures md }
|], [i|KRPCHS/Service/#{srv}.hs|])

main :: IO ()
main = do
  [srcDir] <- getArgs
  let src = [ srcDir ++ "/" ++ nm
            | nm <- [ "KRPC.Drawing.json"
                    , "KRPC.InfernalRobotics.json"
--                    , "KRPC.json"
                    , "KRPC.KerbalAlarmClock.json"
                    , "KRPC.RemoteTech.json"
                    , "KRPC.SpaceCenter.json"
                    , "KRPC.UI.json"
                    ]]
  forM_ src $ \s -> do
    (hs,dst) <- generateModule s
    writeFile ("../../src/"++dst) hs
  return ()
